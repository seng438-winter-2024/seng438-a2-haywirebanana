**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#: 11      |
| ----------------- |
| Student Names:    |
| Ryan Khryss Obiar |
| Armin Sandhu      |
| Parsa Kargari     |
| Jayden Mikulcik   |

### Table of Contents

1. [Introduction](#1-introduction)
2. [Detailed description of unit test strategy](#2-detailed-description-of-unit-test-strategy)
3. [Test cases developed](#3-test-cases-developed)
4. [How the team work/effort was divided and managed](#4-how-the-team-workeffort-was-divided-and-managed)
5. [Difficulties encountered, challenges overcome, and lessons learned](#5-difficulties-encountered-challenges-overcome-and-lessons-learned)
6. [Comments/Feedback](#6-commentsfeedback-on-the-lab-itself)

# 1 Introduction

In this lab, our group got introduced to automating tests using JUnit on the Eclipse IDE. We were tasked and given a software program (“JFreeChart”) to test and write JUnit tests for, while ensuring we follow Javadoc requirements. We specifically tested two classes, being the org.jfree.data.Range class and the org.jfree.data.DataUtilities class, making sure that we are to test 5 methods from each class. The objective of this lab was to learn and get familiar with creating test cases, implementing mock objects, and executing them. 
Our aim was to identify bugs throughout different versions of the JAR program. This involved us learning how to use the Eclipse IDE effectively, making sure our JUnit tests follow the Javadoc set requirements, and successfully executing our mock objects. This lab is great in simulating a real world industry example of a problem a company could have in regards to software another dev built that needs to be tested. By having to resort to the documentation to come up with the requirements needed to be satisfied in the test suite we incorporate the skills we learned from the first lab in needing to identify potential problems a code base could have. 


# 2 Detailed description of unit test strategy

This section is included in the doc : https://docs.google.com/document/d/1OPetiWkR6CstwnGz5F1CcRBCjNPDB2DkA90YMSeIu0Q/edit?usp=sharing
The PDF is also accessible through the repo


# 3 Test cases developed

This section is included in the doc : https://docs.google.com/document/d/1OPetiWkR6CstwnGz5F1CcRBCjNPDB2DkA90YMSeIu0Q/edit?usp=sharing
The PDF is also accessible through the repo

# 4 How the team work/effort was divided and managed

When devising our testing plan we came together as a group and discussed the different strategies we wanted to use when tackling this assignment. We discussed and came up with the plan to continuously swap our peer review partners to ensure that each test was crafted to perfection and meet all the standards that each test needed to uphold .This approach was aimed at maximizing the quality of our test cases by leveraging multiple perspectives. By rotating peer review partners, we ensured that each test was crafted to perfection and met all the necessary standards. It also promoted a collaborative environment where everyone's input and expertise could contribute to the refinement of the testing process. This was decided before we started and each pair worked in conjunction with the other pair to write the test cases at the same time for each method then compare and discuss with the other group. Not only did this allow for every member to be engaged and broaden our knowledge about unit testing and black box testing, this was also beneficial for our code quality. Ultimately, this method allowed for a coherent development experience between the four of us, effective learning, and quality work to be produced. 

# 5 Difficulties encountered, challenges overcome, and lessons learned

Some difficulties we encountered were as a whole using the JUnit framework as most of us had limited experience developing JUnit test suites and executing these test cases. Overall the way to overcome this challenge was to meticulously read and understand the online documentation as this allowed our test cases to have all the functionality that we had planned to implement. Similarly with JMock, there was a good amount of documentation the group had to familiarize ourselves with, but in the end, this did help us overcome this difficulty. The greatest lesson taken away as a group we came away with was learning to come up with an understanding of the technology at hand and using resources to make progress on the assignment. This assignment really emphasized the importance of getting familiarized with documentation, and how useful this can be when developing code. In the end our difficulties directly lead to a better understanding of JUnit/JMock allowing us to overcome the errors in our test cases and expand on our knowledge of JUnit/JMock we learn in class.


# 6 Comments/feedback on the lab itself

Overall feedback on this lab was very positive as we got to use and understand a technology used in the field. This coupled with the critical thinking it took to come up with each method we used meant to our group a lab that is essential to complete in order to round out our skills as software engineers. The general consensus of our group was that the lab was very well designed from the content we had to implement to the workflow of the readme being laid out very well allowing for a great lab experience. 
